# 第一步：导入必要的库（按功能分类并列导入）
# 1.1 数据处理库
import pandas as pd  # 用于Excel文件读取和数据处理
# 1.2 数值计算库
import numpy as np  # 用于数学计算和数组操作
# 1.3 绘图库
import matplotlib.pyplot as plt  # 用于数据可视化
# 1.4 字体配置库
from matplotlib import rcParams  # matplotlib参数配置

# 第二步：中文字体配置（解决中文显示问题）
# 2.1 设置中文字体（并列配置两个字体参数）
# 2.1.1 设置无衬线字体为黑体（支持中文字符显示）
rcParams['font.sans-serif'] = ['SimHei']  # 使用黑体
# 2.1.2 设置负号正常显示（避免中文字体导致的负号显示问题）
rcParams['axes.unicode_minus'] = False  # 正常显示负号

# 第三步：数据读取和初步处理（Excel文件数据加载）
# 3.1 设置Excel文件路径
file_path = r'F:\数学建模国赛-工作项目文件夹\小试牛刀\旭东\2024培训内容\2024培训内容\古塔变形\题目\旭东\1986.xlsx'  # 请将路径替换为你的实际文件路径
# 3.2 读取Excel文件数据
df = pd.read_excel(file_path)

# 第四步：数据结构分析和表头定位（智能识别数据起始位置）
# 4.1 查找表头所在的行（通过"层"关键词定位表头位置）
header_row = df[df.iloc[:, 0] == '层'].index[0] + 1

# 第五步：数据提取和列名设置（构建标准化数据框）
# 5.1 提取表头后的有效数据（选择前5列数据）
df_1986 = df.iloc[header_row:, 0:5]
# 5.2 设置标准化的列名
df_1986.columns = ['层', '点', 'x/m', 'y/m', 'z/m']

# 第六步：数据清洗（按顺序执行三个清洗步骤）
# 6.1 去除空白行并重置索引
df_1986 = df_1986.dropna().reset_index(drop=True)

# 6.2 过滤数值数据行（排除非数值的层数据）
df_1986 = df_1986[pd.to_numeric(df_1986['层'], errors='coerce').notnull()]

# 6.3 数据类型转换（并列转换两个坐标列为数值类型）
# 6.3.1 强制转换x坐标为数值类型（处理可能的非数值数据）
df_1986['x/m'] = pd.to_numeric(df_1986['x/m'], errors='coerce')
# 6.3.2 强制转换y坐标为数值类型（处理可能的非数值数据）
df_1986['y/m'] = pd.to_numeric(df_1986['y/m'], errors='coerce')

# 第七步：变形分析计算（按顺序计算三种变形指标）
# 7.1 倾斜分析：计算每一层与塔底的水平距离差异
df_1986['倾斜距离差'] = np.sqrt((df_1986['x/m'] - df_1986['x/m'].iloc[0])**2 + (df_1986['y/m'] - df_1986['y/m'].iloc[0])**2)

# 7.2 弯曲分析：计算相邻层的水平偏移量
df_1986['相邻层偏移'] = df_1986['倾斜距离差'].diff().abs()

# 7.3 扭曲分析：计算塔顶与塔底的水平角度差异
df_1986['角度'] = np.degrees(np.arctan2(df_1986['y/m'] - df_1986['y/m'].iloc[0], df_1986['x/m'] - df_1986['x/m'].iloc[0]))

# 第八步：分析结果输出（按顺序输出三种分析结果）
# 8.1 倾斜分析结果输出
print("倾斜分析：")
print(df_1986[['层', '倾斜距离差']])

# 8.2 弯曲分析结果输出
print("\n弯曲分析：")
print(df_1986[['层', '相邻层偏移']])

# 8.3 扭曲分析结果输出
print("\n扭曲分析：")
print(df_1986[['层', '角度']])

# 第九步：可视化分析结果（创建三个子图的综合分析图表）
# 9.1 创建图形对象（设置3行1列的子图布局和图形大小）
fig, ax = plt.subplots(3, 1, figsize=(10, 15))

# 9.2 倾斜分析可视化（第一个子图）
# 9.2.1 绘制倾斜距离差折线图
ax[0].plot(df_1986['层'], df_1986['倾斜距离差'], marker='o')
# 9.2.2 设置图表属性（并列设置标题、轴标签和网格）
ax[0].set_title('倾斜分析')  # 设置子图标题
ax[0].set_xlabel('层')  # 设置x轴标签
ax[0].set_ylabel('倾斜距离差 (m)')  # 设置y轴标签
ax[0].grid(True)  # 添加网格

# 9.3 弯曲分析可视化（第二个子图）
# 9.3.1 绘制相邻层偏移折线图（使用橙色）
ax[1].plot(df_1986['层'], df_1986['相邻层偏移'], marker='o', color='orange')
# 9.3.2 设置图表属性（并列设置标题、轴标签和网格）
ax[1].set_title('弯曲分析')  # 设置子图标题
ax[1].set_xlabel('层')  # 设置x轴标签
ax[1].set_ylabel('相邻层偏移 (m)')  # 设置y轴标签
ax[1].grid(True)  # 添加网格

# 9.4 扭曲分析可视化（第三个子图）
# 9.4.1 绘制角度变化折线图（使用绿色）
ax[2].plot(df_1986['层'], df_1986['角度'], marker='o', color='green')
# 9.4.2 设置图表属性（并列设置标题、轴标签和网格）
ax[2].set_title('扭曲分析')  # 设置子图标题
ax[2].set_xlabel('层')  # 设置x轴标签
ax[2].set_ylabel('角度 (度)')  # 设置y轴标签
ax[2].grid(True)  # 添加网格

# 第十步：图形显示（最终展示分析结果）
# 10.1 调整子图布局（避免重叠）
plt.tight_layout()
# 10.2 显示完整的分析图表
plt.show()