# ========== 第一步：导入必要的库 ==========
# 以下库导入为并列关系，用于不同功能模块
import pandas as pd  # 数据处理和分析
import tkinter as tk  # GUI界面创建
from tkinter import filedialog  # 文件对话框

# ========== 第二步：文件读取函数定义 ==========
def 读取表格():
    """
    通过GUI界面选择并读取Excel文件
    
    返回:
    表格: 读取的DataFrame数据
    文件路径: 选择的文件路径
    """
    # 2.1 创建GUI根窗口
    root = tk.Tk()
    root.withdraw()  # 隐藏主窗口
    
    # 2.2 打开文件选择对话框
    文件路径 = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx;*.xls")])
    
    # 2.3 读取文件并返回结果
    if 文件路径:
        表格 = pd.read_excel(文件路径)  # 读取Excel文件
        return 表格, 文件路径
    else:
        return None, None

# ========== 第三步：生产计划制定函数定义 ==========
def 制定生产计划(预测表, 实际需求表, 初始库存=0, 初始缺货量=0, 安全库存比例=0.15, 物料编码='6004010256', 库存成本系数=0.01, 缺货成本系数=1):
    """
    根据预测需求和实际需求制定生产计划
    
    参数:
    预测表: 包含预测需求的DataFrame
    实际需求表: 包含实际需求的DataFrame
    初始库存: 初始库存量
    初始缺货量: 初始缺货量
    安全库存比例: 安全库存比例
    物料编码: 目标物料编码
    库存成本系数: 库存成本系数
    缺货成本系数: 缺货成本系数
    
    返回:
    合并表: 包含生产计划的完整数据表
    """
    # 3.1 数据类型转换和预处理
    预测表['物料编码'] = 预测表['物料编码'].astype(str)  # 转换为字符串类型
    实际需求表['物料编码'] = 实际需求表['物料编码'].astype(str)  # 转换为字符串类型

    # 3.2 筛选指定物料编码的数据
    实际需求表 = 实际需求表[实际需求表['物料编码'] == 物料编码].copy()

    # 3.3 确保周次数据类型一致
    预测表['周次'] = 预测表['周次'].astype(int)  # 转换为整数类型
    实际需求表['周次'] = 实际需求表['周次'].astype(int)  # 转换为整数类型

    # 3.4 数据分组和聚合（并列关系）
    预测表_grouped = 预测表.groupby('周次').agg({'预测需求': 'sum', '销售单价': 'mean'}).reset_index()  # 按周次分组预测数据
    实际需求表_grouped = 实际需求表.groupby('周次').agg({'需求量': 'sum'}).reset_index()  # 按周次分组实际需求数据

    # 3.5 合并预测表和实际需求表
    合并表 = pd.merge(预测表_grouped, 实际需求表_grouped, on='周次', how='left')

    # 3.6 初始化计算列（并列关系）
    合并表['生产计划'] = 0  # 生产计划列
    合并表['库存量'] = 0  # 库存量列
    合并表['缺货量'] = 0  # 缺货量列
    合并表['服务水平'] = 1.0  # 服务水平列
    合并表['库存成本'] = 0.0  # 库存成本列
    合并表['缺货成本'] = 0.0  # 缺货成本列

    # 3.7 初始化计算变量
    上周库存 = 初始库存  # 上周库存量
    上周缺货 = 初始缺货量  # 上周缺货量
    本周生产计划 = 合并表.iloc[0]['需求量']  # 第100周的生产计划设为第101周的实际需求量

    # 3.8 逐周计算生产计划和库存状态
    for i in range(len(合并表)):
        # 3.9 提取当前周次的数据
        预测需求量 = 合并表.iloc[i]['预测需求']  # 当前周预测需求
        实际需求量 = 合并表.iloc[i]['需求量'] if not pd.isna(合并表.iloc[i]['需求量']) else 0  # 当前周实际需求
        销售单价 = 合并表.iloc[i]['销售单价']  # 当前周销售单价

        # 3.10 处理第一周的特殊情况
        if i == 0:
            # 初始生产计划用于第101周
            合并表.iloc[i, 合并表.columns.get_loc('生产计划')] = 本周生产计划
        else:
            # 3.11 计算后续周次的生产计划
            # 基于预测需求和安全库存制定生产计划
            安全库存 = 预测需求量 * 安全库存比例
            本周生产计划 = max(0, 预测需求量 + 安全库存 - 上周库存 + 上周缺货)
            合并表.iloc[i, 合并表.columns.get_loc('生产计划')] = 本周生产计划

        # 3.12 计算库存和缺货状态
        本周库存 = 上周库存 + 本周生产计划 - 实际需求量  # 计算本周库存
        
        if 本周库存 >= 0:
            # 3.13 库存充足的情况
            合并表.iloc[i, 合并表.columns.get_loc('库存量')] = 本周库存
            合并表.iloc[i, 合并表.columns.get_loc('缺货量')] = 0
            合并表.iloc[i, 合并表.columns.get_loc('服务水平')] = 1.0
            上周缺货 = 0
        else:
            # 3.14 库存不足的情况
            合并表.iloc[i, 合并表.columns.get_loc('库存量')] = 0
            合并表.iloc[i, 合并表.columns.get_loc('缺货量')] = abs(本周库存)
            合并表.iloc[i, 合并表.columns.get_loc('服务水平')] = max(0, (实际需求量 + 本周库存) / 实际需求量) if 实际需求量 > 0 else 1.0
            上周缺货 = abs(本周库存)
            本周库存 = 0

        # 3.15 计算成本（并列关系）
        库存成本 = 合并表.iloc[i]['库存量'] * 销售单价 * 库存成本系数  # 库存成本
        缺货成本 = 合并表.iloc[i]['缺货量'] * 销售单价 * 缺货成本系数  # 缺货成本
        
        合并表.iloc[i, 合并表.columns.get_loc('库存成本')] = 库存成本
        合并表.iloc[i, 合并表.columns.get_loc('缺货成本')] = 缺货成本

        # 3.16 更新下一周的初始状态
        上周库存 = 本周库存

    return 合并表

# ========== 第四步：平均值计算函数定义 ==========
def 计算平均值(计划表):
    """
    计算生产计划的各项平均指标
    
    参数:
    计划表: 包含生产计划数据的DataFrame
    
    返回:
    平均值字典: 包含各项平均指标的字典
    """
    # 4.1 计算各项平均指标（并列关系）
    return {
        '平均服务水平': 计划表['服务水平'].mean(),  # 平均服务水平
        '平均库存成本': 计划表['库存成本'].mean(),  # 平均库存成本
        '平均缺货成本': 计划表['缺货成本'].mean()   # 平均缺货成本
    }

# ========== 第五步：结果保存函数定义 ==========
def 保存生产计划和综合结果(所有结果, 综合结果, 文件路径):
    """
    将生产计划和综合结果保存到Excel文件
    
    参数:
    所有结果: 包含所有物料生产计划的字典
    综合结果: 包含综合分析结果的DataFrame
    文件路径: 原始文件路径
    """
    # 5.1 生成输出文件路径
    输出文件路径 = 文件路径.replace('.xlsx', '_生产计划结果.xlsx')
    
    # 5.2 使用ExcelWriter保存多个工作表
    with pd.ExcelWriter(输出文件路径, engine='openpyxl') as writer:
        # 5.3 保存每个物料的生产计划（并列关系）
        for 物料编码, 结果 in 所有结果.items():
            结果.to_excel(writer, sheet_name=f'物料_{物料编码}', index=False)
        
        # 5.4 保存综合结果
        综合结果.to_excel(writer, sheet_name='综合结果', index=False)
    
    print(f"结果已保存到: {输出文件路径}")

# ========== 第六步：主程序函数定义 ==========
def 主程序():
    """
    主程序入口，协调整个生产计划制定流程
    """
    print("=== 生产计划制定系统 ===")
    
    # 6.1 读取预测需求表
    print("请选择预测需求表...")
    预测表, 预测文件路径 = 读取表格()
    if 预测表 is None:
        print("未选择预测需求表，程序退出。")
        return

    # 6.2 读取实际需求表
    print("请选择实际需求表...")
    实际需求表, 实际文件路径 = 读取表格()
    if 实际需求表 is None:
        print("未选择实际需求表，程序退出。")
        return

    # 6.3 获取所有唯一的物料编码
    所有物料编码 = 实际需求表['物料编码'].astype(str).unique()
    print(f"发现 {len(所有物料编码)} 个物料编码: {list(所有物料编码)}")

    # 6.4 初始化结果存储
    所有结果 = {}  # 存储所有物料的生产计划
    综合结果_list = []  # 存储综合分析结果

    # 6.5 为每个物料制定生产计划
    for 物料编码 in 所有物料编码:
        print(f"\n正在处理物料编码: {物料编码}")
        
        # 6.6 制定当前物料的生产计划
        结果 = 制定生产计划(预测表, 实际需求表, 物料编码=物料编码)
        所有结果[物料编码] = 结果
        
        # 6.7 计算当前物料的平均指标
        平均值 = 计算平均值(结果)
        
        # 6.8 添加到综合结果
        综合结果_list.append({
            '物料编码': 物料编码,
            '平均服务水平': 平均值['平均服务水平'],
            '平均库存成本': 平均值['平均库存成本'],
            '平均缺货成本': 平均值['平均缺货成本']
        })
        
        # 6.9 输出当前物料的分析结果
        print(f"平均服务水平: {平均值['平均服务水平']:.4f}")
        print(f"平均库存成本: {平均值['平均库存成本']:.2f}")
        print(f"平均缺货成本: {平均值['平均缺货成本']:.2f}")

    # 6.10 创建综合结果DataFrame
    综合结果 = pd.DataFrame(综合结果_list)

    # 6.11 保存所有结果
    保存生产计划和综合结果(所有结果, 综合结果, 预测文件路径)
    
    print("\n=== 生产计划制定完成 ===")
    print("\n综合结果概览:")
    print(综合结果)

# ========== 第七步：程序执行入口 ==========
if __name__ == "__main__":
    主程序()  # 执行主程序
